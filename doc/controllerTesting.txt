Controller Testing Plan

The controller contains a grouping of classes that rely heavily on classes in
the model and view to have already been finished before they can be properly
tested. Therefore several "dummy" classes will have to be created to allow for
testing certain aspects. Also due to the controllers nature as an interface between the model
and view certain functionality will only be testable after the implementation
of most of the model and views classes. The controller directly implements
three interfaces, KeyListener, ActionListener and GameObserver. KeyListener
simply needs to be able to perform an action if a key on the keyboard is
pressed. Therefore it can be initially tested to see if it correctly determines
that a specific key has been pressed and perform a generic action to confirm
it being pressed by printing a string with the key name. After the robot class has been
implemented the move function will then become testable, upon key press we
will check that the robot has moved in the correct direction by checking the
robots new verticalLocation and horizontalLocation values and comparing them
to the before movement verticalLocation and horizontalLocation values, as well
as performing a visual test on the gameboard. The ActionListener's job is to determine if a
mouse click has taken place and what location has been clicked, whether it is
a hex on the game board or a navigation button. To correctly test
this a "dummy" GUI panel will need to be created to test whether the action is
being correctly interpreted, this will then be checked visually. Unfortunatly actions during the actual game will
not be testable until after the gameBoard Jpanel and the gameboard, hex, and
robot models have been implemented. Once they have been it will be tested
whether when a hex with one or more robots is clicked on the health of each
robot is correctly lowered. The GameObserver only checks whether or
not the game has ended by checking the number of teams with robots that are
still alive, it returns a boolean value of true if there is only one team left
and the game has ended or false otherwise. To test this we will need to create
several "dummy" team classes that only contain an integer value for the current number of alive
robots and see if GameObserver returns the correct boolean value with each
scenario. After the view and models have been completely finished we will be
able to visually test if the game ends when it should. 
For the GameController each of its handleEvent functions and the gameOver()
function will be tested through their corresponding interfaces, whilst the startGame()  
function will not be testable until the view and the MainMenu Jpanel have been
completely implemented, once they have been we will visually test that the
correct start screen has popped up.       

For the team selection, robot AI and the Robot librarian to work properly the
Game controller must check whether or not there is a JSON file present, and
whether or not it is empty. For the testing we will check if there is a JSON
file in the corresponding directory, if there is not we will throw an
exception. There will then be a test to determine if there is any text in the
file throwing an exception if there isn't. 


To initially test the RobotStats class we will create a spreadsheet of values
for each of the stat integers being tracked; kills, deaths, games played,
games ended alive, wins, loses, damage inflicted, damage absorbed and distance
travelled. We will check that each value has been correctly incremented from
0 and if it has not been through an exception. After the gameboard, robot and hex models have been completed we will then
be able to run the testing scenarios within the gameboard main as talked
about earlier. This will allow us to track whether stats values are being
correctly updated during the move and shoot actions as well as the game end
scenario.
The StatsTracker class contains only an array of every robot stats class in
the game. Initially we will only test whether the array is the correct size
for a given number of robots. For further testing the RobotStats class must be
completed, after which we will test whether each array member holds the
correct robot, and if it is NULL throw an exception.  
